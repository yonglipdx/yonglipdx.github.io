## C++ programming language by Barne Stroustrup (4th edition)
## The Preface


## A Tutorial of C++ by Barne Stroustrup.

## The basic 6

  * C++ is statical language.
    - Compiler has to know all variable type when in compile/run? time.

  * A non-zero return value from main() indicates a failure.
  * If no value returned, the system will receive a value indicating successfully completion. 
    - Not every system and execution environment make use of return value.

  * A function declariation may contains arguments which is helpful for reading.
    - `int f(int input)` is same as `f(int) `
    - The compiler will simply ignore the argument unless the declaration is also a function definition.
  * For class member function, the name of the class is also part of the function type ---> ?????
  * Scope and life time
    - local scope, class scope, namespace scope, 
    - for a namespace object, the point of destruction is the end of the program.
    - a object created by "new" "lives" until destroyed by "delete"
  * constexpr: evaluated at compile time.   
      ----> ?????? We allow a constexpr function to be called with non-constant-expression arguments
      in contexts that do not require constant expressions, so that we don’t have to define essentially
      the same function twice: once for constant expressions and once for variables
  * int v[] = {0,1,2,3,4};
    > `for (auto a :v) count << v[a];`
  * Prefer the {} initializer syntax for declarations with a named type; Prefer the = syntax for the initialization in declarations using auto
  * Use nullptr rather than 0 or NULL

## User defined Types
  * A struct is simply a class with its members public by default.

## Modularity

  1. C++ offers namespaces as a mechanism for expressing that some declaration belong together and their names should clash with other names.
  2. void use(int sz) **noexcept** 
    1. function should never thrown an exception can be declared "noexcept".
    2. for all good intend and handling fails, so that the function still throws, the standard library function "terminate" is called immediately. 
  3. A function has no way of completing its assigned task after an exception is thrown. 
    1. "handling" exception simply means doming some minimal local cleanup and rethrowning.
    2. when "new" can't find memory to allocate, std::bad_alloc is thrown.
  4. static_assert<A,S>
    1. prints S as compiler error message if A is not true
  5. Avoid non-inline function definition in headers.
  6. let constructor establish an invariant, and throw if it cannot ------>???????
  7. design error-handling strategy around invariants. ------>??????

## Class
  1. RAII: Resource Acquisition Is Initialization.
     * Avoid naked "new" and "delete"
  2. \<static_cast\>\<int\>(list.size())
     * static_cast does not check the value it is converting ----->??????

  3. A container is an object holding a collection of elements, 

  4. dynamic_cast: "is kind of" and "is instance of" operation
     * If the object pointed to by the argument of dynmaic_cast is not of the expected type, nullptr returned. Usually not failure
   when a different type is unacceptable, we can simple dynamic_cast to a reference type. If the object is not of the expected
   type, bad_cast is thrown.  --failure

  5. Use unique_ptr to avoid naked pointer.

  6. && means rvlue reference and is reference to which can bind an rvalue.
     * A move constructor doesnot take const argument, after all, a move constructor is supposed to remove the value from its argument. 
     * A move operator is applied when an rvalue reference is used to an initializer or as the right-hand side of an assignment.
     * when the programmer knows that a value will not be used again, but the compiler cannot be smart enough to figure that out, the programmer can be specific: y = std::move(x);

  7. Essential Operations
     * **Constructors, destructors, copy operation, move operations** 
     * If a class X has a destuctor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the full complement of functions:

  > 			X(Sometype);	// "ordinary constructor" create an object
  > 			X(); 				// default constructor
  > 			X(const X&)		// copy constructor
  > 			X(const X&&)	// move constructor
  > 			X& operator=(const X&) 	// copy assignment: clean up target and copy
  > 			X& operator=(X&&) 		// move assignment: clean up target and move
  > 			~X() 				// destructor: clean up
  >       Except "ordinary constructor", these special member functions will be generated by the compiler as needed.
  > 			to be explicit about generating default implementation:
  > 	    Y(const Y&) = default;
  >       **if you are explicit about some defaults, other default definitions will not be generated**

      There are five situations in which an object is copied or  moved:
        As the source of an assignment
        As an object initializer
        As a function argument
        As a function return type
        As an exception

      When a class has a pointer or a reference member, it is usually a good idea to be explicit about 
      copy of move operator. The reason is that a pointer or reference will point to something that the
      class needs to delete, in which the default copy would be wrong, or point to something that the
      class must not delete, in which case a reader of the code would like to know that.

      explicit Vector(int s) 	// non implicit conversion from int to vector
        --> Vector v1(7); 	//OK v1 has 7 elements
        --> Vector v2 = 7;	//Error, no implicit conversion from int to vector

	8. Resource management.
		std::vector<thread> my_threads;
		Vector init(int n)
		{
			thread t{heartbeat};
			my_threads.push_back(move(t));
			Vector vec(n)
			...
			return vec;
		}
		This makes resource handles, such as Vector and thread, an alternative to using pointers in many cases----?????

	9. Suppressing Operations
		Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer to a base,
		we simply donnot know what members the derived class has, so we cannot know how to copy it.

		Shape(const Shape&)=delete 				// no copy operations
		Shape& operator=(const Shape&)=delete 

		Shape(Shape&&) = delete;					// no move operations
		Shape& operator=(Shape&&)= delete;		
		
      if user has explicitly declared a destructor, a move operation is not implicitly generated for a class.
		==delete mechanism is general, it can used to suppress any operation.

	10. Make a function a member only if needs direct access to the representation of a class.
	11. declare a member function const if it does not modify the state of its object.
	12. If a class is a container, give it an initializer-list constructor   ---??????
	13. An abstract class typically doesnot need a constructor but a destructor which is virtual------ ?????
	14. access polymorphic objects through pointers and references.
	15. A class with a virtual function should have a virtual destructor.
	16. A function in derived class overrides a virtual function in a base. to make it clear, explicitly overidding:
		void draw() const override; -- tells that draw is virtual function in supperclass.
	17. return container by value (relying on move for efficiency)
	18. by default, declare single-argument constructor explicit.
	19. if a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations.

## Template
	1. In C++98, space is needed between two nested template > >
	2. Template are a compile-time mechanism, so their use incurs no run-time overhead compared to hand-crafted code.
	3. Template value argument is useful in many contexts 
			template<typename T, int N>
         struct Buffer{...}
         Buffer<char, 1024> glob // global buffer statically allocated			
         fuc(){
            Buffer<char, 1024> local // local buffer on the stack
         }
	4. Function Template
	5. Function Object(functor): define object that can be called like function.

		use operator()

	   	template<typename T>
			class Less_than {
				const T val; // value to compare against
				public:
				Less_than(const T& v) :val(v) { }
				bool operator()(const T& x) const { return x<val; } // call operator
         }


         // dummy usage
			Less_than<int> lti {42}; 
         Less_than<string> lts {"Backus"};

			void fct(int n, const string & s)
			{
				bool b1 = lti(n); // tr ue if n<42
				bool b2 = lts(s); // tr ue if s<"Backus"
         }

			//real usage, similar to std::sort()

	   	template<typename C, typename P> // P--> policy object, can be Less_than or others.
			int count(const C& c, P pred)  
			{
				int cnt = 0;
				for (const auto& x : c)
				if (pred(x))
				++cnt;
				return cnt;
			}

			count(vec,Less_than<int>{15}; --> #of elements in vec which less than 15.

	6. lambda expression
		There is notation for implicitly generating function objects;
		[&](int a){return a<x;}  ---->lambda expression.
      Had we wanted to "capture" only x, we could have said so [&x];
		Had we want to give the generated object a copy of x, we could have said so: [=x]
		capture nothing is [], 
		capture All local name used by value is [=]
		capture All local name used by reference is [&]
      Using lambdas can be convenient and terse, but also obscure. For nontrivial 
		actions(say, more than a simple expression), naming the operation so as to more
		clearly state its purpose and to make it reusable.
		
		Example: 

			--->without lambdas	

         void draw_all(){};
         void rotate_all(){};

         void user()
			{
				std::vector<Shape∗> v;
				while (cin)
				   v.push_back(read_shape(cin));
			   draw_all(v); //call draw() for each element
			   rotate_all(v,45); //call rotate(45) for each element
				for (auto p : v) // remember to delete elements
				   delete p;
         }

			--->with lambdas: get rid of draw_all/rotate_all
			template<typename C, typename Oper>
			void for_all(C& c, Oper op) // assume that C is a container of pointers
			{
			   for (auto& x : c)
			      op(*x); // pass op() a reference to each element pointed to
         }

         void user()
			{
				vector<unique_ptr<Shape>> v;
				while (cin)
			  	   v.push_back(read_shape(cin));
				for_all(v,[](Shape& s){ s.draw(); }); // draw_all()
				for_all(v,[](Shape& s){ s.rotate(45); }); // rotate_all(45)
			}

	7. Variddic Templates -> A template can be defiend to accept an arbitrary number of arguments of arbitrary types.
			template<typename T, typename ... Tail>
			void f(T head, Tail... tail)
			{
				g(head); // do something to head
				f(tail...); // tr y again with tail
         }
			The key is: 
				1. do sth for head first (real function g())
				1. recursively call f(Tail). 
			variadic templates are widely used in the stardard library.

	8. Aliases
		---> Every stardard-library container provides value_type as the name of its value type. 
		this allows us to write code that will work for every container that follows this
		convention. 

		template<typename C>
		using Element_type = typename C::value_type; // the type of C’s elements
		template<typename Container>
		void algo(Container& c)
		{
			Vector<Element_type<Container>> vec; // keep results here
	   	// ...
      }
			
		--->Aliasing mechanism can be used to define a new template by binding some or all template argument.
		template<typename Key, typename Value>
		class Map {
		   // ...
		};

		template<typename Value>
		using String_map = Map<string,Value>;
		String_map<int> m; // m is a Map<str ing,int>

	9. Template Compilation Model --->?????
		The type checking provided for templates checks the use of arguments in the template definition
		rather than against an explicit interface (in a template declaration). This provides a compile-time
		variant of what is often called duck typing (‘‘If it walks like a duck and it quacks like a duck, it’s a
		duck’’). Or – using more technical terminology – we operate on values, and the presence and
		meaning of an operation depend solely on its operand values. This differs from the alternative view
		that objects have types, which determine the presence and meaning of operations. Values ‘‘live’’ in
		objects. This is the way objects (e.g., variables) work in C++, and only values that meet an object’s
		requirements can be put into it. What is done at compile time using templates does not involve
		objects, only values.
		The practical effect of this is that to use a template, its definition (not just its declaration) must
		be in scope. For example, the standard header <vector> holds the definition of vector. An unfortunate
		side effect is that a type error can be found uncomfortably late in the compilation process and
		can yield spectacularly bad error messages because the compiler found the problem by combining
		information from several places in the program.

	10. Use template to express algorithms that apply to many argument
	11. Use template to express containers
	12. Template are type-safe, but checking happens too late.
	13. Use "concept" as a design tool -----> ????
	14. Use function object as arguments to algorithm
	15. Use lambda if you need a simple function object in one place only.
	16. There is no separate compilation of templates.: #include template definitions in every translation unit that uses them.
			
##  Library Overview
	1. array, bitset, and tuple are special-purpose containers. they are container.
	2. standard-library are defined in namespace std;

##  String and Regular Expression
	1. The stardard string has a move constructor so retuning even long strings by value is efficient.
	2. String is mutable.
	3. String can be compared
	4. c_str() to get a read-only C-style string(a zero-terminated array of char)
	5. A user can define strings of arbitrary character types. 
		using Jstring = basic_string<Jchar> -->assume we have a Japanese character type Jchar
	6. REGULAR EXPRESSION
		.....
	7. Use at() other than iterators or [] for range checking
	8. Use iterators and [] rather than at() to optimize speed.
	9. use a string_stream or a generic value extraction function (such as to<x>) for numberic conversion
	10. A basic string can be used to make strings of characters of any type.
	11. use regex for most conventional uses of regular expressions
	12. use regex_match() to match a complete input
	13. USe regex_search() to search for a pattern in a input stream.
	14. Uaw regex_iterators for iterating over a stream looking for a pattern

## I/O stream
	1. The I/O stream library provides formatted and unformatted buffered I/O of text and numeric values.
	4. The operations on istream and ostreams are type-safe, type-sensitive and extensible to handle user-defined types.

	5. Output (ostream)
	   ostream --> converts typed objects to a stream of characters(bytes). can be chained.
		<ostream>, I/O stream defines output for every build-in type. Further, it is easy to defined output of a user-defined type.
	   << (put to) is used as an output operator on object of type ostream, such as cout(standard output stream) and
	   cerr (standard error stream). By default values written to cout are converted to a sequence of characters. 

	6. Input (istream)
	   istream --> converts a stream of characters (bytes) to typed objects. can be chained.
		>> ("get from") is used for input operator.
		string str; cin >> str.
		By default, a whitespace character, such as space or newline, terminates the read. 
		Use getline(0 to read a whole line. 
		string str; getline(cin, str);

	7. I/O state (iostream)
		An iostream has a state that we can e examine to determine whether an operation succeeded.
		In general, the I/O state holds all the info needed to read or write, such as formatting info,
		error state(eg. end-of-input been reached), and what kind of buffer is used. User can set the 
		state to reflect that an error has occurred and clear the state if an error was not serious. 
	
	8. I/O of user-defined Types

		struct Entry {
		  string name;
		  int number;
		};		

		// easy for output
		ostream& operator<<(ostream& os, const Entry& e)
		{
			return os << "{\"" << e.name << "\", " << e.number << "}";
		}
		
		//complicate for input
		istream& operator>>(istream& is, Entry& e){
	      ...	
		}

	9. Formatting
		output integers as decimal(defaul), octal, hexadecimal..
		cout << 1234 << ',' << hex << 1234 << ',' << oct << 1234 << '\n'; // pr int 1234,4d2,2322
		Precison: determine the number of digits used to display a floating-point number.
		general foramt/scientific/fixed format. 
     	cout.precision(8);
	   cout << 1234.56789 << ' ' << 1234.56789 << ' ' << 123456 << '\n';
	   cout.precision(4);
	   cout << 1234.56789 << ' ' << 1234.56789 << ' ' << 123456 << '\n';
	     This produces:
				 1234.5679 1234.5679 123456
				 1235 1235 123456

	10. File Stream <fstream>
		ifstreasm -> reading from file
		ofstream -> writing to file
		fstream for reading and writing to a file.
		
		ofsteam ofs("target");  //ofs for output
		if (!ofs)
			error("couldn't open 'targe' for writing");
		ofs can be sued as an ordinary ostream(jsut like cout)

		fstream ifs;	// "i" for "input"
		if(!ifs)
			error("couldnot open 'source' for reading");
		ifs can be sued as an ordinary istream just like cin
	
	11. stringstream <sstream>
		istringstream for reading from a string
		ostringstream for writing to a string
		stringstream for reading and writing to a string
		
	12. Tips
		define << and >> for user-defined types with values that have meaningful textual representation.
		there are iostream for ordinary characters and wide characters, and you can define an iostream
		for any kind of character.
		
	13. Binary I/O is supported.
	14. Chain <<, >> operators for a terser notation. 
	15. By default >> skip initial whitespace.
	16. Donot try to copy a file stream
	17. Remember to check that a file stream is attached to a file before using it.
	18. user stringstream for in-memory formatting
	
## Container
	1. A class with the main purpose of holding objects is commonly called container.
	2. vector: use it as default container. 
		A vector is a sequence of elements of a given type. The elements are stored contiguously in memory.
		The standard-library vector has members capacity(), push_back(), reserve()..
		If you have a class hierarchy that relies on virtual functions to get polymorphic behavior, 
		do not store objects directly in a container. Instead store a pointer (or a smart pointer).
					 vector<Shape> vs; // No, don¡¯t - there is no room for a Circle or a Smiley
					 vector<Shape.>vps; //better, but see ¡×4.5.4
					 vector<unique_ptr<Shape>> vups; // OK

		Standard-library vector does not guarantee range checking. 
		  void silly(vector<Entry>& book)
		  {
			  // no error reported. i will receive some random value !!!!
		     int i = book[book.size()].number; // book.size() is out of range
		     // ...
        }

		  A simple range check Vec on top of standard vector.
			
					 template<typename T>
					 class Vec : public std::vector<T> {
						public:
							using vector<T>::vector; // use the constructors from vector (under the name Vec)
							T& operator[](int i) // range check
							{ return vector<T>::at(i); }
							const T& operator[](int i) const // range check const objects; §4.2.1
							{ return vector<T>::at(i); }
					 };

	3. List: a double-linked list:   
           3.5 forward_list: single-linked list.
	4. map: a balanced binary tree (red-black tree). nlgn. searching.
	5. unordered_map: hash container
  6. 
	    vector<T> A variable-size vector (§9.2)
		  list<T> A doubly-linked list (§9.3)
		  forward_list<T> A singly-linked list
		  deque<T> A double-ended queue
		  set<T> A set (a map with just a key and no value)
		  multiset<T> A set in which a value can occur many times
		  map<K,V> An associative array (§9.4)
		  multimap<K,V> A map in which a key can occur many times
		  unordered_map<K,V> A map using a hashed lookup (§9.5)
		  unordered_multimap<K,V> A multimap using a hashed lookup
		  unordered_set<T> A set using a hashed lookup
		  unordered_multiset<T> A multiset using a hashed lookup
		  array<T,N> fixed-size array
		  bitset<N>. 
	7. basic operator for all container: begin(), end(), size(), 
	8. push_back() can be used for vector, list, and others.
        9. use reserve() to avoid invalidating pointers and iterators to elements.
	10. use push_back(), resize() on a container rather than realloc() on an array	
	11. Element are copied into a container.
	12. pass a container by reference and return a container by value.
	13. for a container, use ()-initializer syntax for sizes and {}-initializer syntax for list of elements.
	14. A list is relatively expensive to traverse.
	15. use unordered containers for fast lookup in large a amounts of data
	16. use ordered containers (eg. map, set) if need to iterate over their elements in order.
	17. hash function obtained by combining standard hash functions for elements using exclusive or are often good.

## Algorithms

  *
    void f(vector<Entry>& vec, list<entry>& lst){
      sort(vec.begin(), vec.end()));
      unique_copy(vec.begin(), vec.end(), lst.begin());
    }

    in this example, to write the output to list, we need specify the lst element to be written. if more elements to 
    be written, the elements followed the initial element will be overwritten. Thus, to avoid error, 1st must have as 
    many element as there are unique values in vec. 
     
    If we want to place the unique elements in a new container, we could have done:
    
    list<Entry> f(vector<Entry>& vec)
    {
      list<Entry> res;
      sort(vec.begin(), vec.end());
      unique(vec.begin(), vec.end(), back_inserter(res));
      return res;
    }

    the call back_inserter(res) construct an iterator for res that adds elements at the end of the container, entending
    container to make room for them. This save us from first having to allocate a fixed amount of space and then filling i1.t.
    back_inserter eliminate the C-style error-prone realloc().
    Standard-library list has a move constructor that make return res by value efficient.
    Q: how move constructor is selected instead of copy?

  * Any particular iterator is an object of some type. What is common for all iterators i their semantics and the nmaing of their
   operations. For example, ++ yields an iterator that refers to the next element, * yields the element to which the iterator refers.
   User rarely need to know that type of a specific iterator, each container "knows" its iterator types and makes them available 
   under the conventional names iterator and const_iterator. 

  *  Stream iterators
      Similar to container, iterator can be applied to input/output as well.

  *  To make ostream_iterator, we need specity

      which stream will be used --> cout
      type of the object --> string

      the effect os assigning to *oo is to write te assigned value to cout. for example:

      ostream_iterator<string> oo{cout}
      int main(){
         *oo = "Hello";  // meaning cout << "Hello"
         ++oo;
         *oo = "World!\n"; // meaning cout << "wold\n"
      }

  *  istream_iterator need specify the stream to be used and the type of values expected.
      istream_iterator<string> ii{cin};
      Input iterators are used in pairs representing a sequence, se we must provide an istream_iterator
      to indicate the end of input. This is the default istream_iterator:
         istream_iterator<string> eos{};

  * Typically, istream_iterator/ostream_iterator are not used directly. Instead, they are provided as arguments to 
      algorithms. For example, we can write a simle program:
         read a file
         sort the words
         eliminste duplicates
         write the result to another file.

        ~~~~
        int main()
        {
            string from, to;
            cin >> from >> to;

            ifstream is{from};  //ifstream is an istream that can be attached to a file
            istream_iterator<string> ii{s};
            istream_iterator<stinr> eos{};

            ofstream os{to};  // ofstream is an ostream that can be attached to a file
            ostream_iterator<string> oo{os, "\n"}; // "\n" to delimit output value. 

            vector<string> b{ii,eos};
            sort(b.being,b.end());
            unique_copy(b.begin(), b.end(), oo);
            return !is.eof() || !os;
        }
        ~~~~

        ```
         Use set to avoid sort/remove_duplication.
         int main()
         {
             string from, to; 
             cin >> from >> to; // get source and target ﬁle names
              ifstream is {from}; // input stream for ﬁle "from" 
              ofstream os {to}; // output stream for ﬁle "to"
              set<string> b {istream_iterator<string>{is},istream_iterator<string>{}}; // read input
              copy(b.begin(),b.end(),ostream_iterator<string>{os,"\n"}); // copy to output
              return !is.eof() || !os; // retur n error state (§1.3, §8.4)
         } 
        ```

  * find element from a map which meet a special requirement (predicates).
        search a map for the first value larger than 42.

         version 1.

         void f(map<string,int>& m) {
            auto p = ﬁnd_if(m.begin(),m.end(),Greater_than{42});
            // ... 
         } Here, Greater_than is a function object (§5.5) holding the value (42) to be compared against:
         
         struct Greater_than { int val;
            Greater_than(int v) : val{v} { } 
            bool operator()(const pair<string,int>& r) { return r.second>val; }
         };

         version II (lambda):
         auto p = ﬁnd_if(m.begin(), m.end(), [](const pair<string,int>& r) { return r.second>42; }); 

  * 
      p=nd(b,e ,x) p is the ﬁrst p in [b:e) so that *p==x
      p=nd_if(b,e ,f) p is the ﬁrst p in [b:e) so that f(*p)==true 
      n=count(b,e ,x) n is the number of elements *q in [b:e) so that ∗q==x 
      n=count_if(b,e ,f) n is the number of elements *q in [b:e) so that f(*q,x) 
      replace(b,e ,v,v2) Replace elements ∗q in [b:e) so that *q==v by v2 replace_if(b,e ,f,v2) 
      Replace elements *q in [b:e) so that f(*q) by v2 p=copy(b,e ,out)
      Copy [b:e) to [out:p) p=copy_if(b,e ,out,f) 
      Copy elements *q from [b:e) so that f(*q) to [out:p) p=move(b,e ,out)
      Move [b:e) to [out:p) p=unique_copy(b,e ,out) 
      Copy [b:e) to [out:p); don’t copy adjacent duplicates
      sor t(b,e) Sort elements of [b:e) using < as the sorting criterion 
      sor t(b,e,f) Sort elements of [b:e) using f as the sorting criterion 
      (p1,p2)=equal_rang e(b,e ,v) [p1:p2) is the subsequence of the sorted sequence [b:e) with the value v; basically a binary search for v 
      p=merge(b,e ,b2,e2,out) Merge two sorted sequences [b:e) and [b2:e2) into [out:p)
      
      these algorithms and many more can be applied to elements of containers, strings, and built-in arrays.

  * An STL algorithm operates on one or more sequences.
  * An input sequence is half-open and defined by a pair of iterator.
  * Algorithms do not directly add or subtract elemens from their argument sequences.
  * Use predicates and other function objects to give standard algorithms a wider range of meanings. 
  * A predicate must not modify its argument.

## Utilities
   1. The standard library components are designed not to leak resources. 
   2. In <memory> standard library provide:
   3. ** unique_ptr: represent unique ownership  ---> moved **
      void (int i, int j){
         X *p = new X;
         unique_ptr<X> sp {new X};

         if (i < 99 ) throw Z{}; // may thrown an exception
         if (j < 77) return;     // may return "early"

         p->do_sth();            // may throw an exception
         sp->do_sth;             // may throw an exception
         //

         delte p; // this may not work in case of exception, early return..
      }
   
   4. ** shared_ptr: represent shared ownership ----> copied. **
        The shared_ptrS for an object share ownership of an object and
                  that object is destroyed when the last of its shared_ptrS is destroyed. 
        void f(shared_ptr<fstream>);
        void g(shared_ptr<fstream>);

        void user(const string& name, ios_base::openmode mode){
           shared_ptr<fstream> fp {new fstream(name, mode))};
           if (!*fp) throw No_file{};

           f(fp);
           g(fp);
           //..
        }

        Now the file opened by fp-s constructor will be closed by the last function to (explicitly or implicitly) destroy a copy of fp.
        Not that f() or g() may spawn a task holding a copy of fp or in some other way store a copy that outlives user(). Thus, shared_ptr
        provides a form of garbage collection that respects the destructor-based resource management of the memory-managed objects.  this 
        is neight cost free nor exorbitantly expensive. but it does make the lifetime of the shared object hard to predict. Use shared_ptr 
        only if you actually need shared ownership.

    5. make_shared()

      struct S{
         int i;
         string s;
         double d;
      };

      shared_ptr<S> p1 {new S{1, "First, Last", 3.14}};
      ||      
      auto p1 = make_shared_<S>(1, "First,Last", 3.14);

      However there is no standard-library make_unique which can be defined as:
      template<typename T, typename... Args>
      unique_ptr<T> make_unique(Args&&... args){
         return std::unique_ptr<T>{new  T{std::forward<Args>(args)...}};
      }
      now, we can use
      auto p1 = make_unique<S>(1, "First,Last", 3.14);

   6. smart pointer are still the second choice for resource management - after containers and other types that
      manage their resources at a higher conceptual level. 
      shared_ptr becomes obvious choice when we need pointers (or references) to refer to the shared object.
      unique_ptr becomes the obvious choice we we refer to a polymorphic object, we need a pointer(or reference) 
      because we donot know the exact type of the object referred to.
      a shared polymorphic object typically requires shared_ptrS.

   7. Almost containers
      T[N]         Built-in array: a fixed-size continuously allocated sequence of N elements of type T; implicitly converts to a T∗
      array<T,N>   A fixed-size continuously allocated sequence of N elements of type T; like the built-in array, but with most problems solved
      bitset<N>    A fixed-size sequence of N bits
      vector<bool> A sequence of bits compactly stored in a specialization of vector
      pair<T,U>    Two elements of types T and U
      tuple<T...>  A sequence of an arbitrary number of elements of arbitrary types
      basic_string<C> A sequence of characters of type C; provides string operations
      valarray<T>  An array of numeric values of type T; provides numeric operations

      • pair and tuple are heterogeneous; all other containers are homogeneous (all elements are of the same type).
      • array, vector, and tuple elements are contiguously allocated; forward_list and map are linked structures.
      • bitset and vector<bool> hold bits and access them through proxy objects; all other standard-library
        containers can hold a variety of types and access elements directly.
      • basic_string requires its elements to be some form of character and to provide string manipulation, 
        such as concatenation and locale-sensitive operations
      • valarray requires its elements to be numbers and to provide numerical operations.

   8. array. defined in <array> is a fixed-size sequence of elements of a given type where the number of elements is specified in
             compile time. Thus, an array con be allocated with its elements on the stack. 
         array<int,3> a1 = {1,2,3}; // OK
         array<int>   ax = {1,2,3}; // error size not specified
         array<int, n>   ax = {1,2,3}; // error size not constant expression.
         
         when necessary, an array can be explicitly passed to a C-style function that expect a pointer.
         Occasionally, there is significant performance advantage to be had by directly accessing elements 
         allocated on the stack rather than allocating elements on the free store. 
         but be careful that stack is limited resource(especially on some embedded systems) and stack overflow is nasty.
         
         array vs build-in array:
         1. array know its size
         2. it can be copied (using = or initialization)
         3. prevent nasty conversion to pointer, example:

            void h()
            {
               Circle a1[10];
               array<Circle,10> a2;
               // ...
               Shape∗ p1 = a1; // OK: disaster waiting to happen
               Shape∗ p2 = a2; // error : no conversion of array<Circle,10> to Shape* so that p2[3].draw() is avoid
               p1[3].draw(); // disaster
            }
 
   9. bitset： class bitset<N> provide a sequence of N bits [0:N) where N is known at compile time. 
               For sets of bits that donot fit inot a long long int, uisng a bitset is much more convenient than using integers directly. 
               for smaller sets, bitset is usually optimized. If you want to name the bits, rather than numbering them, you can use a set or 
               an enumeration. 

         A bit set can be initialized with an integer or a string:
         bitset<9> bs1{"110001111"};
         bitset<9> bs2{399};

      The usual bitwise operation can be applied, as can left- and right-shift operations (<< and >>):
         bitset<9> bs3 = ˜bs1; // complement: bs3=="001110000"
         bitset<9> bs4 = bs1&bs3; // all zeros
         bitset<9> bs5 = bs1<<2; // shift left: bs5 = "111000000"
      the shift operators "shifts in" zeros.

      operations to_ullong() and to_string() provide the inverse operations to the constructors. 
      
      void binary(int i)
      {
         bitset<8xsizeof(int)> b = i; // assume 8-bit byte (see also §12.7)
         cout << b.to_string() << '\n'; // wr ite out the bits of i
         // cout << b << '\n'; // write out the bits of i--> same as above
      }

   10. pair, tuple
      tuple<string,int,double> t2{"Sild",123, 3.14}; // the type is explicitly specified
      auto t = make_tuple(string{"Herring"},10, 1.23); // the type is deduced to tuple<string,int,double>
      string s = get<0>(t); // get first element of tuple: "Herring"
      int x = get<1>(t); // 10
      double d = get<2>(t); // 1.23

   11. Time <chrono>
      using namespace std::chrono; // see §3.3
      auto t0 = high_resolution_clock::now();
      do_work();
      auto t1 = high_resolution_clock::now();
      cout << duration_cast<milliseconds>(t1−t0).count() << "msec\n";

	12. Function adapters
		A function adaptor takes a function as argument and returns a function object that can be used to invoke the original
		function. The standard library provides bind() and mem_fn() adaptors to do argument binding, also called Currying or partial evaluation. 
		Binders were heavily used in the past, but most uses seem to be more easily expressed using lambdas.

	13. Bind()
		Given a function and a set of arguments, bind() produces a function object that can be called with "the remaining" argument of the function.

		using namespace placeholders; // std::placeholders is part of <functional>
		void original_f(int, const string&)
		auto g= bind(original_f,2,_1) // bind original_f first argument to 2

		_1 argument to the binder is a placeholder telling bind() where arguments to the resulting function object should go.
		In this case, g() (first) argument is used as original_f second argument.

		original_f(2,"hello");
		g("hello") // same as above call  

		To bind arguments for an overloaded function, we have to explicitly state which version of the function we want to bind.

		int pow(int, int);
		double pow(double, double); //pow is overloaded
		
		auto pow2 = bind(pow,_1, 2); // error. Which pow()?
		auto pow2 = bind((double(*)(double, double))pow,_1, 2) 

	14. mem_fn()
		mem_fn(mf) produces a function object that can be called as a nonmember function. 

		void user(Shape* p){
			p->draw();
			auto draw = mem_fn(&Shape::draw);
			draw(p);
		}

		The major used of mem_fu() is when an algorithm requires an operation to be called as a nonmember function. For example:

		void draw_all(vector<Shape*>& v){
			for_each(v.begin(), v.end(), mem_fn(&Shape::draw));
		}
		then mem_fn() can be seen as a mapping from the object-oriented calling style to the functional one.
		often, lambdas provide a simple and general alternative to binders. For example:
		void draw_all(vector<Shape*>& v){
			for_each(v.begin(), v.end(), [](Shape* p){p->draw();});
		}

	15. function: 
		The starndard-library function is a type that can hold any object you can invoke the call operator ().
		-> an object of type function is a function object. 

		int round(double x) {return staic_case<int>(floor(x=0.5));}  // conventional rounding
		function<int(double)> f; //f can hold anything that can be called with a double and return an int.

		enum class Round_style (truncate, round};

		struct Round {	// function object carrying a state
			Round_style s;
			Round(Round_style ss):s(ss){};
			int operator()(double x) const {return static_case<int>((s==Round_style::round)? (x+0.5):x);};
			// use staic_cast to make it explicit that i want to return an int.


		void test(){

         function<int(double)> f;

			f = round;
			cout << f(7.6) // ------> 8

			f = Round(Round_style::truncate);
			count << f(7.6); // -----> 7

		   Round_style style = Round_style::round;
			f = [style](double x){return static_castKint>((style==Round_style::round)? x+0.5:x);};	
			cout << f(7.6)  ----------> 8. call lambda

			vector<double> v{7.6};
			f = Round(Round_style::round);
			std::transform(v.begin(), v.end), v.begin(), f); // pass to algorithm
			cout << v[0]; -------------> 8. //transformed by the lambda

			Obviously, functions are useful for callbacks, for passing operations as arguments, etc.

	16.type function is a function that is evaluated at compile-time given a type as its argument or retuning a type.
		The standard library privides a variety type functions.
		
		for numerical types, numeric_limits from <limits> presents a variety of useful info.

			constexpr float min = numeric_limits<float>::min();
			constexpr int szi = sizeof(int);
		such type function for compiler-time computation that allow tigher type checking and better performance.
		use such features is often call metaprogramming or template metaprogramming (with tempalte is involved).

      ---> iterator_traits 
			exampkle: std::sort need random access to the sequence which much work on random-access iterators. in this case, 
			forward_list(singly-linked list) which offer forward iterators cannot be used directly for sort()
			std:: iterator_traits allows us to check which kind of iterator is supported. 

			template<typename Ran> // for random-access iterators
			void sort_helper(Ran beg, Ran end, random_access_iterator_tag) // we can subscript into [beg:end)
			{
				sort(beg,end); // just sort it
			}

			template<typename For> // for forward iterators
			void sort_helper(For beg, For end, forward_iterator_tag) // we can traverse [beg:end)
			{
				vector<Value_type<For>> v {beg,end}; // initialize a vector from [beg:end)
				sor t(v.begin(),v.end());
				copy(v.begin(),v.end(),beg); // copy the elements back
			}

			Value_type<For> is the type of For-s elements., called it-s value type. Every std iterator has a member value_type.

			I get the Value_type<For> notation by defining a type alias.
         template<typename C>
				using Value_type = typename C::value_type; //C-s value type

			Thus, v is a vector<X> where X is the element type of the input sequence.

			the real magic is in the selection of helper functions:

			template<typename C>
			void sort(C& c)
			{
				using Iter - Iterator_type<C>;
				ort_helper(c.begin(), c.end(), Iterator_category<Iter>{});
			}

         Above example uses two type functions:
					Iterator_type<C>
						 return C::iterator // iterator type of C
					Iterator_category<Iter>{} 
						 constructs a "tag" value indicating the kind of iterator provided:
							1. std::random_access_iterator_tag if C-s iterator supports random access
							2. std::forward_iterator_tag if C-s iterator supports random access

			The standard-library support for techniques for using iterators, such as tag dispatch, comes in the form of a simple class template iterator_traits from <iterator>.
			This allows simple definitions of the type functions used in sor t():

				template<typename C>
			  		 using Iterator_type = typename C::iterator; // C’s iterator type

				template<typename Iter>
					using Iterator_category = typename std::iterator_traits<Iter>::iterator_category; // Iter’s categor y

				If you don’t want to know what kind of ‘‘compile-time type magic’’ is used to provide the standardlibrary
				features, you are free to ignore facilities such as iterator_traits. But then you can’t use the
				techniques they support to improve your own code.
			



		 ---> Type predicates in <type_traits>
			std:: type predicate a simple type function to answer a fundamental quesiton about type: 
			bool b1 = ls_arithmatic<int>();  // Yes
			bool b1 = ls_arithmatic<string>(); //No

			is_class, is_pod, is_literal_type, has_virtual_destructor, is_base_of.  They are most useful when we write templates

	17. A library doesnot have to be large or complicated to be useful
	18. A resource is anything that has to be acquired and (explicity or implicityly) released.
	19. Use resource handler to manage resources (RAII).
	20. User unique_ptr to refer to objects of polymorphics type
	21. Uee shared_ptr to refer to shared obejcts.
	22. Prefer uique_ptr to shared_ptr;
	23. use arry where you need a sequence with a constexpr
	24. Prefer array over build-in arrays.
	25. Uer bitset if you need N bits and N is not necessarily the number of bits in a built-in integer type
	26. when using pair/tuple, consider make_pair/tuple() for type deduction.
	27. Time your programs before making measurements with proper units.
	28. Often, a lambda is an alternative to using bind() or men_fn()
	29. use bin() to create variants of functions and function objects
	30. Use mem_fn() to create function objects that can invoke a member function when called using the traditionally  function call notation.
	31. Use function when you need to store sth that can be called
	32. You can write code to explicitly depend on properties of types.

## Numeric 

	1. Mathematical functions <cmath>
		abs(x) Absolute value
		  ceil(x) Smallest integer >= x
		  floor(x) Largest integer <= x
		  sqr t(x) Square root; x must be non-negative
		  cos(x) Cosine
		  sin(x) Sine
		  tan(x) Tangent
		  acos(x) Arccosine; the result is non-negative
		  asin(x) Arcsine; the result nearest to 0 is returned
		  atan(x) Arctangent
		  sinh(x) Hyperbolic sine
		  cosh(x) Hyperbolic cosine
		  tanh(x) Hyperbolic tangent
		  exp(x) Base e exponential
		  log(x) Natural logarithm, base e; x must be positive
		  log10(x) Base 10 logarithm		
		Error are reported from <cerrno> 
	   domain error: errno->EDOM 
      range error:  errno-> ERANGE 

		void f(){
			errno = 0;
			sqrt(-1);
			if (errno == EDOM){
				cerr << "sqrt() not defined for negative argument"

			error = 0; // clear old error state
			pow(numerica_limits<double>::max();2)
			if (errno == ERANGE)
				cerr << "result of pow() too large to represent as a double";
		}
	
	2. Numerical Algorithms <numeric>
		A small set of generalized numerical algorithms.
		x=accumulate(b,e,i)					x is the sum of the elements of [b:e)
		x=accumulate(b,e,i,f)				accululate using f instead of =
		x=inner_product(b,e,b2,i)			x is the inner product of [b:e) and [b2:b2+(e-b))
													that is, the sum of i and (*p1)(*p2) for each p1
													in [b:e) and the corresponsing p2 in [b2:b2+(e-b))
		x=inner_product*b2,e,b2,i,f,f2) 	iner_product using f and f2 inst0ad of + and *
		x=partial_sum(b,3,out) 				Element i of [out:p) is the sum of of elements [b:b+i]
		x=partial_sum(b,3,out,f) 		   partial_sum using f instead of +
		p=adjacent_difference(b,e,out)
		p=adjacent_difference(b,e,out,f)
		iota(b,e,v)								For each element in [b:e) assign ++v; thus the sequence becomes v+1, v+2...
			
		These algorithms work for every standard-library sequence and can have operations supplied as arguments.
	
	3. Complex number	<comlex> 
		the standard library complex is a template
		template<typename Scalar>
		class complex{
			public:
				complex(const& Scalar& re={}, const Scalar& im={});
				//...
		}

		The usual arithmetic operations and the most common mathematical functions are supported for complex numbers.
		void f(complex<float> fl, complex<double> db){
			complex<long double> ld{fl+sqrt(db)};
			db += fl*3;
			fl = pow(1/f1,2);
		}
		The sqrt() and pow() are among the usual mathematical functions defined in  <complex>

	4. Random Numbers
		A random number consist of two parts.
		1. An engine that produces a sequence of random or pseudo-random values.
		2. A distribution that maps those values into a mathematical distribution in a range.
			uniform_int_distribution, normal_distribution, exponential_distribution. 

		using my_engine = default_random_engine;					// type of engine
		using my_distribution = uniform_int_distribution<>		// type of distribution
		my_engine re{};													// the default engine
		my_distribution one_to_six {1,6};							// distribution that maps to the ints 1..6
		auto die = bind(one_to_six,re);								// make a generator
		int x = die();														// roll the die: x becomes a value in [1:6]	

	5. Vector Arithmetic <valarray>
		vallarray is less general and more amenable to optimization for numerical computation than <vector>

		template<typename T>
		class valarray {
			//...
		}

		The usual arithmetic operations and the most common mathematical functions are supported for valarrays.
		void f(valarray<double>& a1, valarray<double>& a2){
			valarray<double> a = a1*3.14 + a2/a1;  		// numeric array operations*,+,/ and =
			a2 += a1*3.14;
			a = abs(a);
			double d = a2[7];
			//...
		}
		In particular, valarray offers stride access to help multidimensional computations.

	6. Numeric Limits <limits>
		<limits> provide classes that describe the properties of built-in types - such as the maximum 
		exponent of a float or the number of bytes in an int. 
		
		static_assert(numeric_limits<char>::is_signed,"unsigned characters!");
		static_assert(1000000<numeric_limits<int>::max(),"small ints!");  // Ok since numeric_limits<int>::max() is a constexpr function()

		Use numeric_limits to check that the numeric types are adequate for their use

## Concurrency
	The standard-library support is primarily aimed at supporting systems-level concurrency rather than directly providing sophisticated
	higher-level concurrency models. Those can be supplied as libraries built suing the standard-library facilities.
	The STD supports concurrent execution of multiple threads in a single address space. To allow that, C++ provides a suitable memory model and 
	a set of atomic operations. 
	The atomic operations allows lock-free programming.
	The memory model ensures that as long as a programmer avoids data races(uncontrolled concurrent access to mutable data), everything works 
	as one wold naively expect. However, most users wills ee concurrency only in terms of the standard library and libraries built on top of that.

	1. Tasks and threads
		we call a computation that can potentially be executed concurrently with other computations a task. 
		A thread is the system-level representation of a task in a program.  A task to be executed concurrently with other tasks is launched by 
		constructing a std::thread with the task as its arguments.

		void f();					// function
		struct F{					// function object
			void operator()() 	// F-s call operator
		};
		
		void user(){
			thread t1 {f};
			thread t2(F()};
			t1.join();
			t2.join();
		}

		The joins()s ensure user() stay alive until threads have completed. 
		join means to wait for the thread to terminate.
		threads of a program share a single address space. 

		void f() {cout << "Hello";}
	 	struct F{
			void operator()(){ count << "Parallel World!\n";}
		}
		A bad example for above user() as f and F() use the obejct cout without any form of synchronization. 
		The result ouput would be unpredictable. An combined message "PaHeralllel o world!" may reached.

		The simplest way of thinking of a concurrent task is as a function that happens to run concurrently with its
		caller. That that to work, we just have to pass arguments, get a result back, and make sure that there is no 
		use of shared data in between (no data races).

	2. Passing arguments.
		
		void f(vector<double>& v);		
		struct F{
			vector<double>& v;
			F(vector<double>&vv:v(vv));
			void operator()();
		};

		int main){
			vector<double> some_vec{1,2,3,5};
			vector<double> vec2{10, 8, 0, 11,12};
			thread t1 {f,ref(some_vec)}
			thread t2 {F(vec2}};

			t1.join();
			t2.join();
		}

		-->Problem: be careful that the vectors can be modified somewhere else as they are passed by reference
			
	3. returning results 

		-->Answer: A common techniques to avoid the above pitfall is to use const input and seperate ouput

		void f(const vector<double>& v, double∗ res); // take input from v; place result in *res

		class F {
		  public:
		  F(const vector<double>& vv, double∗ p) :v{vv}, res{p} { }
		  void operator()(); // place result in *res
		  private:
		  const vector<double>& v; // source of input
		  double∗res; //target for output
		};

		int main()
	   {
		  vector<double> some_vec;
		  vector<double> vec2;
		  // ...
		  double res1;
		  double res2;
		  thread t1 {f,cref(some_vec),&res1}; // f(some_vec,&res1) executes in a separate thread
		  thread t2 {F{vec2,&res2}}; // F{vec2,&res2}() executes in a separate thread
		  t1.join();
		  t2.join();
		  cout << res1 << ' ' << res2 << '\n';
		}

	4. Sharing data and deadlock
		The solution is mutex, a "mutual exclusion object". A thread acquires a mutex using a lock() operation.
		
		mutex m; // controlling mutex
		in sh; 	// shared data

		void f(){
			unique_lock<mutex> lck{m}; // acquire mutex
			sh += 7;
			// release mutex IMPLICITLY
		}
		
		the unique_lock-s constructor acquires the mutex (through a call m.lock()). If another thread has already acquired the mutex
		the thread waits until the other thread completes its access.  Once a thread has completed its access to the shared data, the
		unique_lock release the mutex (with a call m.unlock()), 

		in cases there are muliple resources to be acquired, to adoid deadlock:
		void f(){
			unique_lock<mutex> lck1{m1, defer_lock}; // defer_lock: donnot yet try to acquired the muext
			unique_lock<mutex> lck1{m2, defer_lock}; // defer_lock: donnot yet try to acquired the muext
			unique_lock<mutex> lck1{m3, defer_lock}; // defer_lock: donnot yet try to acquired the muext
			//...
			lock(lck1, lck2, lck3);
			// manipulate shared data...
		} //  impplicity release all mutexes
		this lock will proceeded only after acquiring all its mutex arguments and will never "back" ("go to sleep") while 
		holding a mutex. 
		the destructor for the individual unique_locks ensure that the mutexes are released when a thread leaves the scope.

		Shared data could be be inferior to the notion of call and return.

	5. Waiting for events.
		Sometime, a thread needs to wait for some kind of external event, such as another thread completing a task or a certain
		amount of time having passed. the simplest "event" is simply time passing. <chrono>

			----- example of tracing run time (no thread)
				  include <chrono>
				  ...
				  using namespace std::chrono;
				  auto t0 = hih_resolution_clock::now();
				  this_thread::sleep_for(millseconds{20});
				  auto t1=high_resolution_clock::now();
				  cout << duration_cast<nanoseconds>(t1-t0).count() << "nanoseconds passed\n";
				  use duration_cast to adjust the clock-s unit to the nanoseconds. 
			-------

		The basic support for communicating using external events is provided by condition_variables. 
		
		class Message{	// object to be communicated
			//...
		};

		queue<Message> mqueue;		// the queue of messsages
		condition_variable mcond;	// the variable communicating events
		mutex mmutex;					// the locking mechanism
		
		void consumer(){
			while (true){
				unique_lock<mutex> lck{mmutex};
				while (mcond.wait(lck)) /*don thing */ // release lck and wait;
																	// re-acquire lck upon wakeup
				
				auto m = mqueue.front(); 					// get the message
				mqueue.pop(); 									// release lck
				// ... process m...
			}
		}

		void producer(){
			while(true){
				Message m;
				// fill the message
				unique_lock<mutex> lck {mmutex}; 	//protect operations
				mqueue.push(m);
				mcond.notify_)one() 		// notify
			}	// release lock (while scope release)
		}

		Here condtion_variable release its lock in consumer() until that wait is over. (receiving mcond.notify_one() from producer?)
		
		
	5. Communication Tasks <future>
		1. future and promise
			For returning a value from a task spawned on a separate thread	
			The basic idea is simple: when a task wants to pass a value to another, it puts the value into a promise. Somehow, this value
			will appear in the corresponding future, from which it can be read (typically be the launcher of the task).

			void f(promise<X>& px){ // a task: place the resul in px
				//...
				try {
					X res;
					//... do something with res
					px.set_value(res);
				}catch(...){
					px.set_exception(current_exception()); // pass the exception to the future-s thread
					// current_exception() refers to the caught exception.
				}
			}

			The main purpose for promise is to provide a simple put operation set_vaalue() and set_exception to match future-s get().
			
			void g(future<X> &fx)[
				//...
				try{
					X v=fx.get();
					// ... use v...
				} catch(...){
					//... handle error..
				}
			}
			
			NO LOCK
			
		2. packaged_task
			To help launch tasks and connect up the mechanisms for returning a result

		  // compute the sum of [beg:end) starting with the initial value init
		  double accum(double∗ beg, double∗ end, double init) {
				return accumulate(beg,end,init);
   		}

   	  double comp2(vector<double>& v) {
			 using Task_type = double(double∗,double∗,double); // type of task
			 packaged_task<Task_type> pt0 {accum}; // package the task (i.e., accum)
			 packaged_task<Task_type> pt1 {accum};
			 future<double> f0 {pt0.get_future()}; ------>  // get HOLD of pt0’s future
			 future<double> f1 {pt1.get_future()}; -------> // get HOLD of pt1’s future
			 double∗ first = &v[0];
			 thread t1 {move(pt0),first,first+v.siz e()/2,0}; // star t a thread for pt0
			 thread t2 {move(pt1),first+v.siz e()/2,first+v.siz e(),0}; // star t a thread for pt1
			 // ...
			 return f0.get()+f1.g et(); // get the results
        }

			the packaged_task template takes the type of the task as its template argument(here Task_type, an
			alias for double(double*, double*, double) and the task as its constructor argument(here, accum). 
			the move(0 operations are needed because a packaged_task cannot be copied because it is a resource
			handler: it owns its promise and is(indirectly) responsible for whatever resources its task may own.

			NO LOCK.
			
		3. async() ---> can we use dynamic task count?
			For launching of a task in a manner very similar to calling a function
			to launch tasks to potentially run asynchronously, we can use async().

			double comp4(vector<double>& v){
				if (v.size() < 1000)
					return accum(v.begin(0, v.end(), 0.0);

				auto v0 = &v[0];
				auto sz = v.size();
				auto f0 = async(accum, v0, v0+sz/4, 0.0); // first quater
				auto f1 = async(accum, v0+sz/4, v0+sz/2, 0.0); 
				auto f2 = async(accum, v0+sz/2, v0+sz*3/4, 0.0); 
				auto f3 = async(accum, v0+sz*3/4, v0+sz, 0.0); 
				return f0.get() + f1.get() + f2.get() + f3.get();
			}

			async() cabn also be used to spawn a task for getting info from user. leving the "main program" active with something else.

			NO LOCK

		4. The standard-library concurrency facilities are type safe.
		5. Atomics allow for lock-free programming
		6. Leave lock-free programming to experts
		7. A thread is a type-safe interface to a system thread
		8. User join() to wait for a thread to complete
		9. Prefer package_task and future over direct use of threads and mutexs
		10. Return a result using promise and get a result from a future
	   11. use packaged_tasks to handle exceptions thrown by tasks and to arrange for value return.
		12. use a packaged_task and future to express a request to an external service and wait for its response.
		13. Use async() to launch simple task
				
	

### VI
   set spell spelllang=en_us
   set syntax=c++/java/latex/python...
   set tabstop=3 softtabstop=0 noexpandtab shiftwidth=3
   set guifont=Lucida_Console:h10  
   spell ]s-> find next. z= -> spell suggetion zg -> add word to dictionary

###change git default editor:
	Add gvim path to system PATH (e.g C:\Programs Files (x86)\Vim\vim74
	git config --global core.editor [to_gvim_path_without_exe]

###change gvim background color: 
	In .vimrc
   	colorscheme koehler

### Make gvim compatible with Chinese character
	In .vimrc:
   	set encodding=utF8
   	set guifontwide=NSimSun

### to solve conflict issue simpliar to sync/commit in perforce.
### git stash
### git pull
### git stash pop
###  resolve conflict if any
###  git push origin master

### syntax highlight in gvim
        set syntax=cpp
        set syntax=lex
 
### Lex
	Scanner produces a stream of tokens from the input source.
	lex is a scanner generator.
	lex input is set of regular expressions and associated action (wirtten in C)
	lex output is a table-driven scanner (lex.yy.c)
	flex: an open source implementation of lex.

	### lex input
		first part (optional)
		table size demision
		defination of text replacement
		global C code (specail syntax required)
		...
		%% -----> termination of FIRST PART
		pattern	action
		regular expression and action
		action and be C statment or block of C code.
		...
	 	%% ------> termination of SECOND PARt
		Third PART (optional)
		C code simplied used as is.

	Example: filename: exl.l
	--------
	%%
	"hello world"	printf("goodbye\n");
	.		;  ----> ignore everthing other than "hello world"
	%%
	--------

	lex exl.1 ----> generate a scanner, saved as lex.yy.c
	cc lex.yy.c -ll  (with -ll option main() is grab from the lex library)


	Example2: suppose we have configuration file "config.in"
	--------

### yacc



### char* const vs    const char*
	according to the standard, const modifies the element directly to its left. 
	The use of const at the beginning of a declaration is just a convenient mental shortcut. 
	So the following two statements are equivalent:
	char const * pointerToConstantContent1;
	const char * pointerToConstantContent2;

	In order to ensure the pointer itself is not modified, 
	const should be placed after the asterisk:
	char * const constantPointerToMutableContent;

	To protect both the pointer and the content to which it points, use two consts.
        char const * const constantPointerToConstantContent;
	
	

### stringstream:
	example1: 
	  string a("123");
          stringstream ss(a);
	  ss << "456"
	  cout << aa.str(); ---> 456
	
        example2:
	  string a("123");
          stringstream ss("");
	  ss << a << << "456"
	  cout << aa.str(); ---> 123456

### ssize_t size_t

        to avoid i == -1
        size_t i: 
                 if (i > -1) // not OK since i always > -1
                 use i< (size_t)-1  to make sure i > -1;
        ssize_t i: 
		 i > -1 is OK since i could be -1 in ssize_t




